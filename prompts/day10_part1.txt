You will be provided a vector of configurations, each as a string.
This is an example configuration:

[.##.] (3) (1,3) (2) (2,3) (0,2) (0,1) {3,5,4,7}

It consists of three components:

* A 'endstate' between [].  In this case it is ['.','#','#','.'].
  It is an error for this to be empty.
* A series of possible steps, which are whitespace separated.
  In this case the steps are:
    [(3), (1,3), (2), (2,3), (0,2), (0,1)].
  It is an error for this to be empty, or to have invalid positions (here,
  4 would be an invalid position).
* A final set of numbers between {} that you can ignore (here: 3,5,4,7).

The endstate consists of a number of positions -- in this case, there are 4.
A '.' represents a deactivated state, a '#' represents an activated state.
Each system starts in the all deactivated position: ['.', '.', '.', '.']
in the above example, since there are 4 positions.  

Each step will flip the current state of the specified position(s): if it is '.'
it will become '#', and if it is '#' it will become '.'.
So, for example, if the system is in state ['.', '#', '.', '#']
then selecting the step (0,1) will change the state to be ['#', '.', '.', '#'].

The goal is to find the minimum number of steps in order to go from the initial,
all deactivated, position to the desired endstate.  Steps must be taken
an integral number of times.

For the above example, possible sequences of steps that achieve the end state
are:

* (3), (1,3), (2), which requires 3 steps.
* (1,3), (2,3), (0,1), (0,1), which requires 4 steps.
* (3), (2), (2,3), (0,2), (0,1)], which requires 5 steps.
* (1,3), (2,3) which requires 2 steps.

The latter is the minimum number of steps, so the answer for this
particular instance is 2.  There may be multiple possible sequences that
require the same number of steps, but we don't care which sequence is chosen,
simply how long it is.

Other examples:

1.  '[...#.] (0,2,3,4) (2,3) (0,4) (0,1,2) (1,2,3,4) {7,5,12,7,2}'

the answer is 3, which can be achived by the steps (0,4), (0,1,2), (1,2,3,4).

2. '[.###.#] (0,1,2,3,4) (0,3,4) (0,1,2,4,5) (1,2) {10,11,11,5,10,5}'

the answer is 2, with one sequence (0,3,4), (0,1,2,4,5).

Your task is to take the input vector of such problems, find the minimum
number of steps to achieve the desired endstate, and then sum those values
for all individual inputs.  So, for example, if the 3 examples were the input,
the returned value should be 2 + 3 + 2 = 7.

To accomplish this, you shoul:wasd complete the implementation of the part1
function in the specified file.  You must:

- Most critially, solve the problem correctly.
- Add unit tests that cover the examples provided, but also go beyond them
  to include additional edge cases and in general improve the coverage.
  If you do not do this, you have failed.
- Modify the signature of the function in order to handle errors.
  You should also handle the case where a solution cannot be found.

Beyond those goals, you should prioritize clarity, but you should also
consider efficiency when it does not result in radically more complex code;
the actual configurations may be much larger and more difficult than the above
examples.  However, it is safe to assume there are 32 or fewer positions;
you should return an error if that is not the case.

We generally expect there to be more steps than positions, although
not dramatically so.  It is safe to expect there are fewer than 64, and
return an error if not.

Note that you are not required to run main, as that will fail due to missing 
inputs.  Looking at other files in the repository is not useful,  except 
possibly lib.rs.
